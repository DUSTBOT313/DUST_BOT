import json
import time
import base58
import os
from solana.rpc.api import Client
from solana.rpc.types import TxOpts
from solana.keypair import Keypair
from solana.publickey import PublicKey
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction, Transaction
from solders.system_program import TransferParams, transfer
from solders.spl.token.instructions import burn, close_account, BurnParams, CloseAccountParams
from solders.spl.token.constants import TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID
import requests
from flask import Flask, jsonify, request
from flask_cors import CORS
import telebot

app = Flask(__name__)
CORS(app)

# Config
RPC_ENDPOINT = os.getenv('RPC_ENDPOINT', 'https://api.mainnet-beta.solana.com')
WALLET_PRIVATE_KEY_B58 = os.getenv('WALLET_PRIVATE_KEY')
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', '8293367338:AAGJZlGNUDDXx3H88GkTvyuBCcAXA5sjlhU')
MINI_APP_URL = os.getenv('MINI_APP_URL', 'https://dust-jzt3jnjgf-dust-bot.vercel.app')
JUPITER_QUOTE_API = "https://quote-api.jup.ag/v6/quote"
JUPITER_SWAP_API = "https://quote-api.jup.ag/v6/swap"
INCINERATOR_API = "https://v1.api.sol-incinerator.com"
DEXSCREENER_API = "https://api.dexscreener.com/latest/dex/tokens/"
PUMP_API = "https://frontend-api.pump.fun/coins?offset=0&limit=500"
WALLET_PUBKEY = PublicKey("B99peTzS2ZRXkZLpcE3CbisFXkxZ77EEWwgkGRbkuWmb")
SOL_MINT = PublicKey("So11111111111111111111111111111111111111112")
INCINERATOR_ADDR = PublicKey("1nc1nerator11111111111111111111111111111111")
FEE_WALLET = PublicKey("9tzPdS72tm7vE8669BkghpsFaiR3Z1VS9K8rdEDeFQRD")
API_KEY = os.getenv('INCINERATOR_API_KEY', '')
LAMPORTS_PER_SOL = 1_000_000_000

INACTIVE_VOLUME_THRESHOLD = 100
MIN_SWAP_AMOUNT_LAMPORTS = 100
SLIPPAGE_BPS = 1
DELAY_SEC = 1
DEX_DELAY_SEC = 2
TX_OPTS = TxOpts(skip_preflight=True, preflight_commitment="processed")
BATCH_SIZE = 10

client = Client(RPC_ENDPOINT)
if WALLET_PRIVATE_KEY_B58:
    keypair_bytes = base58.b58decode(WALLET_PRIVATE_KEY_B58)
    keypair = Keypair.from_bytes(keypair_bytes)
    if keypair.pubkey() != WALLET_PUBKEY:
        raise ValueError("Private key mismatch!")
else:
    raise ValueError("Set WALLET_PRIVATE_KEY env var!")

bot = telebot.TeleBot(TELEGRAM_TOKEN)
headers = {"x-api-key": API_KEY} if API_KEY else {}

successful_buys = 0
total_fees_sent = 0.0

def get_balance():
    return client.get_balance(WALLET_PUBKEY).value / LAMPORTS_PER_SOL

def fetch_meme_coins():
    response = requests.get(PUMP_API)
    if response.status_code != 200:
        return []
    coins = response.json()
    inactive_coins = []
    for coin in coins:
        if 'mint' not in coin:
            continue
        mint = coin['mint']
        symbol = coin.get('name', 'UNK')[:4].upper()
        dex_resp = requests.get(f"{DEXSCREENER_API}{mint}")
        if dex_resp.status_code == 200:
            dex_data = dex_resp.json()
            if dex_data.get('pairs'):
                volume_h24 = float(dex_data['pairs'][0].get('volume', {}).get('h24', 0))
                if volume_h24 < INACTIVE_VOLUME_THRESHOLD:
                    inactive_coins.append((symbol, mint))
        time.sleep(DEX_DELAY_SEC)
    return inactive_coins

def get_quote(input_mint, output_mint, amount_lamports):
    params = {
        "inputMint": str(input_mint),
        "outputMint": str(output_mint),
        "amount": amount_lamports,
        "slippageBps": SLIPPAGE_BPS,
        "onlyDirectRoutes": False,
    }
    response = requests.get(JUPITER_QUOTE_API, params=params)
    if response.status_code == 200:
        quote = response.json()
        if int(quote.get('outAmount', 0)) > 0:
            return quote
    return None

def execute_swap(quote_response):
    global successful_buys
    swap_request = {
        "quoteResponse": quote_response,
        "userPublicKey": str(WALLET_PUBKEY),
        "wrapAndUnwrapSol": True,
        "computeUnitPriceMicroLamports": 0,
    }
    response = requests.post(JUPITER_SWAP_API, json=swap_request)
    if response.status_code == 200:
        swap_tx_b64 = response.json()["swapTransaction"]
        tx = VersionedTransaction.from_bytes(base58.b58decode(swap_tx_b64))
        tx.sign([keypair])
        sig = client.send_transaction(tx, opts=TX_OPTS).value
        print(f"Swap TX: https://solscan.io/tx/{sig}")
        successful_buys += 1
        return True
    return False

def get_token_accounts():
    accounts = []
    for program_id in [TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID]:
        resp = client.get_token_accounts_by_owner(WALLET_PUBKEY, {"program_id": program_id}, commitment="confirmed")
        for acc_info in resp.value:
            acc_pubkey = acc_info.pubkey
            balance_resp = client.get_token_account_balance(acc_pubkey)
            if balance_resp.value and int(balance_resp.value.amount) > 0:
                accounts.append({
                    'account': acc_pubkey,
                    'mint': PublicKey(balance_resp.value.mint),
                    'amount': int(balance_resp.value.amount),
                    'program_id': program_id
                })
    return accounts

def manual_burn_batch(accounts_batch):
    tx = Transaction()
    reclaimed = 0
    for acc in accounts_batch:
        try:
            burn_ix = burn(BurnParams(
                program_id=acc['program_id'],
                account=acc['account'],
                mint=acc['mint'],
                authority=WALLET_PUBKEY,
                amount=acc['amount']
            ))
            tx.add(burn_ix)
            close_ix = close_account(CloseAccountParams(
                program_id=acc['program_id'],
                account=acc['account'],
                dest=WALLET_PUBKEY,
                owner=WALLET_PUBKEY,
                authority=WALLET_PUBKEY
            ))
            tx.add(close_ix)
            reclaimed += 0.002
        except Exception as e:
            print(f"Failed to add manual IX for {acc['mint']}: {e}")
    if len(tx.instructions) > 0:
        tx.sign(keypair)
        try:
            sig = client.send_transaction(tx, opts=TX_OPTS).value
            print(f"Manual Batch Burn/Close TX ({len(accounts_batch)} accounts): https://solscan.io/tx/{sig}")
            return True, reclaimed
        except Exception as e:
            print(f"Manual batch failed: {e}")
            return False, 0
    return False, 0

def auto_burn_via_api(accounts):
    total_reclaimed = 0
    api_success_count = 0
    manual_count = 0
    for acc in accounts:
        if headers:
            preview_resp = requests.post(f"{INCINERATOR_API}/burn/preview", json={
                "userPublicKey": str(WALLET_PUBKEY),
                "assetId": str(acc['account'])
            }, headers