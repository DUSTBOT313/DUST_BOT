import json
import time
import base58
import os
from solana.rpc.api import Client
from solana.rpc.types import TxOpts
from solana.keypair import Keypair
from solana.publickey import PublicKey
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction, Transaction
from solders.system_program import TransferParams, transfer
from solders.spl.token.instructions import burn, close_account, BurnParams, CloseAccountParams
from solders.spl.token.constants import TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID
import requests
from flask import Flask, jsonify, request
from flask_cors import CORS
import telebot

app = Flask(__name__)
CORS(app)

# Config
RPC_ENDPOINT = os.getenv('RPC_ENDPOINT', 'https://api.mainnet-beta.solana.com')
WALLET_PRIVATE_KEY_B58 = os.getenv('WALLET_PRIVATE_KEY')
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', '8293367338:AAGJZlGNUDDXx3H88GkTvyuBCcAXA5sjlhU')
MINI_APP_URL = os.getenv('MINI_APP_URL', 'https://dust-jzt3jnjgf-dust-bot.vercel.app')
JUPITER_QUOTE_API = "https://quote-api.jup.ag/v6/quote"
JUPITER_SWAP_API = "https://quote-api.jup.ag/v6/swap"
INCINERATOR_API = "https://v1.api.sol-incinerator.com"
DEXSCREENER_API = "https://api.dexscreener.com/latest/dex/tokens/"
PUMP_API = "https://frontend-api.pump.fun/coins?offset=0&limit=500"
WALLET_PUBKEY = PublicKey("B99peTzS2ZRXkZLpcE3CbisFXkxZ77EEWwgkGRbkuWmb")
SOL_MINT = PublicKey("So11111111111111111111111111111111111111112")
INCINERATOR_ADDR = PublicKey("1nc1nerator11111111111111111111111111111111")
FEE_WALLET = PublicKey("9tzPdS72tm7vE8669BkghpsFaiR3Z1VS9K8rdEDeFQRD")
API_KEY = os.getenv('INCINERATOR_API_KEY', '')
LAMPORTS_PER_SOL = 1_000_000_000

INACTIVE_VOLUME_THRESHOLD = 100
MIN_SWAP_AMOUNT_LAMPORTS = 100
SLIPPAGE_BPS = 1
DELAY_SEC = 1
DEX_DELAY_SEC = 2
TX_OPTS = TxOpts(skip_preflight=True, preflight_commitment="processed")
BATCH_SIZE = 10

client = Client(RPC_ENDPOINT)
if WALLET_PRIVATE_KEY_B58:
    keypair_bytes = base58.b58decode(WALLET_PRIVATE_KEY_B58)
    keypair = Keypair.from_bytes(keypair_bytes)
    if keypair.pubkey() != WALLET_PUBKEY:
        raise ValueError("Private key mismatch!")
else:
    raise ValueError("Set WALLET_PRIVATE_KEY env var!")

bot = telebot.TeleBot(TELEGRAM_TOKEN)
headers = {"x-api-key": API_KEY} if API_KEY else {}

successful_buys = 0
total_fees_sent = 0.0

def get_balance():
    return client.get_balance(WALLET_PUBKEY).value / LAMPORTS_PER_SOL

def fetch_meme_coins():
    response = requests.get(PUMP_API)
    if response.status_code != 200:
        return []
    coins = response.json()
    inactive_coins = []
    for coin in coins:
        if 'mint' not in coin:
            continue
        mint = coin['mint']
        symbol = coin.get('name', 'UNK')[:4].upper()
        dex_resp = requests.get(f"{DEXSCREENER_API}{mint}")
        if dex_resp.status_code == 200:
            dex_data = dex_resp.json()
            if dex_data.get('pairs'):
                volume_h24 = float(dex_data['pairs'][0].get('volume', {}).get('h24', 0))
                if volume_h24 < INACTIVE_VOLUME_THRESHOLD:
                    inactive_coins.append((symbol, mint))
        time.sleep(DEX_DELAY_SEC)
    return inactive_coins

def get_quote(input_mint, output_mint, amount_lamports):
    params = {
        "inputMint": str(input_mint),
        "outputMint": str(output_mint),
        "amount": amount_lamports,
        "slippageBps": SLIPPAGE_BPS,
        "onlyDirectRoutes": False,
    }
    response = requests.get(JUPITER_QUOTE_API, params=params)
    if response.status_code == 200:
        quote = response.json()
        if int(quote.get('outAmount', 0)) > 0:
            return quote
    return None

def execute_swap(quote_response):
    global successful_buys
    swap_request = {
        "quoteResponse": quote_response,
        "userPublicKey": str(WALLET_PUBKEY),
        "wrapAndUnwrapSol": True,
        "computeUnitPriceMicroLamports": 0,
    }
    response = requests.post(JUPITER_SWAP_API, json=swap_request)
    if response.status_code == 200:
        swap_tx_b64 = response.json()["swapTransaction"]
        tx = VersionedTransaction.from_bytes(base58.b58decode(swap_tx_b64))
        tx.sign([keypair])
        sig = client.send_transaction(tx, opts=TX_OPTS).value
        print(f"Swap TX: https://solscan.io/tx/{sig}")
        successful_buys += 1
        return True
    return False

def get_token_accounts():
    accounts = []
    for program_id in [TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID]:
        resp = client.get_token_accounts_by_owner(WALLET_PUBKEY, {"program_id": program_id}, commitment="confirmed")
        for acc_info in resp.value:
            acc_pubkey = acc_info.pubkey
            balance_resp = client.get_token_account_balance(acc_pubkey)
            if balance_resp.value and int(balance_resp.value.amount) > 0:
                accounts.append({
                    'account': acc_pubkey,
                    'mint': PublicKey(balance_resp.value.mint),
                    'amount': int(balance_resp.value.amount),
                    'program_id': program_id
                })
    return accounts

def manual_burn_batch(accounts_batch):
    tx = Transaction()
    reclaimed = 0
    for acc in accounts_batch:
        try:
            burn_ix = burn(BurnParams(
                program_id=acc['program_id'],
                account=acc['account'],
                mint=acc['mint'],
                authority=WALLET_PUBKEY,
                amount=acc['amount']
            ))
            tx.add(burn_ix)
            close_ix = close_account(CloseAccountParams(
                program_id=acc['program_id'],
                account=acc['account'],
                dest=WALLET_PUBKEY,
                owner=WALLET_PUBKEY,
                authority=WALLET_PUBKEY
            ))
            tx.add(close_ix)
            reclaimed += 0.002
        except Exception as e:
            print(f"Failed to add manual IX for {acc['mint']}: {e}")
    if len(tx.instructions) > 0:
        tx.sign(keypair)
        try:
            sig = client.send_transaction(tx, opts=TX_OPTS).value
            print(f"Manual Batch Burn/Close TX ({len(accounts_batch)} accounts): https://solscan.io/tx/{sig}")
            return True, reclaimed
        except Exception as e:
            print(f"Manual batch failed: {e}")
            return False, 0
    return False, 0

def auto_burn_via_api(accounts):
    total_reclaimed = 0
    api_success_count = 0
    manual_count = 0
    for acc in accounts:
        if headers:
            preview_resp = requests.post(f"{INCINERATOR_API}/burn/preview", json={
                "userPublicKey": str(WALLET_PUBKEY),
                "assetId": str(acc['account'])
            }, headers=headers)
            if preview_resp.status_code == 200:
                preview = preview_resp.json()
                print(f"Preview for {str(acc['mint'])[:8]}...: Reclaim ~{preview.get('reclaimedSol', 0)} SOL + rewards")

        api_success = False
        for attempt in range(2):
            if headers:
                burn_resp = requests.post(f"{INCINERATOR_API}/burn", json={
                    "userPublicKey": str(WALLET_PUBKEY),
                    "assetId": str(acc['account'])
                }, headers=headers)
                if burn_resp.status_code == 200:
                    tx_b64 = burn_resp.json()["serializedTransaction"]
                    tx = VersionedTransaction.from_bytes(base58.b58decode(tx_b64))
                    tx.sign([keypair])
                    sig = client.send_transaction(tx, opts=TX_OPTS).value
                    print(f"Auto-Burn TX (w/ rewards): https://solscan.io/tx/{sig}")
                    api_success = True
                    api_success_count += 1
                    total_reclaimed += 0.002
                    break
                else:
                    print(f"API attempt {attempt+1} failed: {burn_resp.text}")
                    time.sleep(1)

        if not api_success:
            print(f"Falling back to manual burn for {str(acc['mint'])[:8]}...")
            batch = [acc]
            success, reclaimed = manual_burn_batch(batch)
            if success:
                total_reclaimed += reclaimed
                manual_count += 1
            else:
                print(f"Manual burn failed for {acc['mint']}")

        time.sleep(1)

    if headers:
        batch_resp = requests.post(f"{INCINERATOR_API}/batch/close-all", json={
            "userPublicKey": str(WALLET_PUBKEY)
        }, headers=headers)
        if batch_resp.status_code == 200:
            for tx_b64 in batch_resp.json().get("transactions", []):
                tx = VersionedTransaction.from_bytes(base58.b58decode(tx_b64))
                tx.sign([keypair])
                sig = client.send_transaction(tx, opts=TX_OPTS).value
                print(f"API Batch Close TX: https://solscan.io/tx/{sig}")

    print(f"API burns: {api_success_count}, Manual burns: {manual_count}")
    print(f"Total estimated reclaim: ~{total_reclaimed} SOL (check wallet)")
    return total_reclaimed

def burn_all_tokens():
    accounts = get_token_accounts()
    print(f"Found {len(accounts)} dusty accounts to burn.")
    if not accounts:
        print("No tokens to burn.")
        return 0
    return auto_burn_via_api(accounts)

def send_remaining_to_incinerator():
    balance_lamports = client.get_balance(WALLET_PUBKEY).value
    if balance_lamports > 5_000 and balance_lamports < 1_000_000:
        ix = transfer(TransferParams(
            from_pubkey=WALLET_PUBKEY,
            to_pubkey=INCINERATOR_ADDR,
            lamports=balance_lamports - 5_000
        ))
        tx = Transaction().add(ix)
        tx.sign(keypair)
        sig = client.send_transaction(tx, opts=TX_OPTS).value
        print(f"Burned dust SOL: https://solscan.io/tx/{sig}")

def send_transaction_fees():
    global total_fees_sent
    num_txs = successful_buys
    if num_txs == 0:
        return
    fee_lamports = int(0.00001 * LAMPORTS_PER_SOL * num_txs)
    balance_lamports = client.get_balance(WALLET_PUBKEY).value
    if balance_lamports > fee_lamports + 5000:
        to_send = min(fee_lamports, balance_lamports - 5000)
        ix = transfer(TransferParams(
            from_pubkey=WALLET_PUBKEY,
            to_pubkey=FEE_WALLET,
            lamports=to_send
        ))
        tx = Transaction().add(ix)
        tx.sign(keypair)
        sig = client.send_transaction(tx, opts=TX_OPTS).value
        fee_sol = to_send / LAMPORTS_PER_SOL
        print(f"Sent {num_txs} tx fees ({fee_sol:.8f} SOL to {FEE_WALLET}): https://solscan.io/tx/{sig}")
        total_fees_sent += fee_sol

def run_dust_bot():
    global successful_buys
    successful_buys = 0
    MEME_COINS = fetch_meme_coins()
    print(f"Proceeding with {len(MEME_COINS)} inactive coins.")
    for symbol, token_addr in MEME_COINS:
        current_balance = get_balance()
        if current_balance < 0.0000002:
            print("Out of dust! Starting auto-burn phase.")
            break
        print(f"Buying dust from inactive {symbol}...")
        quote = get_quote(SOL_MINT, PublicKey(token_addr), MIN_SWAP_AMOUNT_LAMPORTS)
        if quote and execute_swap(quote):
            print(f"Got dust from inactive {symbol}!")
        time.sleep(DELAY_SEC)
    burn_all_tokens()
    send_remaining_to_incinerator()
    send_transaction_fees()
    return successful_buys

@bot.message_handler(commands=['start'])
def start_handler(message):
    markup = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True)
    btn_launch = telebot.types.KeyboardButton('Launch Dashboard', web_app=telebot.types.WebAppInfo(url=MINI_APP_URL))
    markup.add(btn_launch)
    bot.reply_to(message, "Welcome to Solana Dust Bot! Connect your wallet and start accumulating dust.", reply_markup=markup)

@bot.message_handler(commands=['status'])
def status_handler(message):
    status = f"Successful Buys: {successful_buys} | Fees Sent: {total_fees_sent:.6f} SOL"
    bot.reply_to(message, status)

@bot.message_handler(commands=['run'])
def run_handler(message):
    bot.reply_to(message, "Running dust accumulator...")
    buys = run_dust_bot()
    bot.reply_to(message, f"Completed {buys} buys! Check logs.")

@bot.message_handler(commands=['burn'])
def burn_handler(message):
    bot.reply_to(message, "Burning dust...")
    reclaimed = burn_all_tokens()
    bot.reply_to(message, f"Reclaimed ~{reclaimed} SOL!")

@bot.message_handler(func=lambda message: True)
def echo_handler(message):
    bot.reply_to(message, "Use /start for dashboard, /status, /run, or /burn.")

@app.route('/webhook', methods=['POST'])
def webhook():
    update = telebot.types.Update.de_json(request.get_json())
    bot.process_new_updates([update])
    return 'OK', 200

@app.route('/api/run-bot', methods=['POST'])
def api_run_bot():
    buys = run_dust_bot()
    return jsonify({'logs': f'Completed {buys} buys, fees sent'})

@app.route('/api/burn', methods=['POST'])
def api_burn():
    reclaimed = burn_all_tokens()
    return jsonify({'reclaimed': reclaimed})

@app.route('/api/logs', methods=['GET'])
def api_logs():
    return jsonify(['Dust bot logs...'])

@app.route('/api/status', methods=['GET'])
def api_status():
    return jsonify({
        'successful_buys': successful_buys,
        'total_fees_sent': total_fees_sent,
        'fee_wallet': str(FEE_WALLET)
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
